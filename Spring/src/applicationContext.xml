<?testXml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation=" http://www.springframework.org/schema/beans
                            http://www.springframework.org/schema/beans/spring-beans.xsd
                            http://www.springframework.org/schema/context
       					    http://www.springframework.org/schema/context/spring-context.xsd
                            http://www.springframework.org/schema/aop
       					    http://www.springframework.org/schema/aop/spring-aop.xsd">

    <context:component-scan base-package="testAnnotation"/>
    <!--
        <bean>配置需要创建的对象
            id：用于之后从spring容器获得实例对象时使用
            class：需要创建的对象的全类名
    -->
    <!--<bean id="demoBean" class="testIoC.DemoImpl"/>-->

    <!--
        <property> 用于进行属性的注入
            name：该属性对应的外层bean的成员变量名
            ref：该属性的bean id
    -->
    <!--<bean id="dao" class="testDI.DaoImpl"/>-->
    <!--<bean id="service" class="testDI.ServiceImpl">-->
    <!--<property name="dao" ref="dao"/>-->
    <!--</bean>-->

    <!--
            使用Spring实现静态工厂
            这里class为静态工厂的全类名
            factory-method为静态工厂生产该对象是调用的静态方法名
        -->
    <!--<bean id="demoBeanStaticFactory" class="testInject.staticFactory.MyBeanFactory" factory-method="getDemo"/>-->

    <!--
        Spring实例工厂
        先配置实例工厂的bean
        在要生产的bean中设置实例工厂以及方法
        factory-bean为实例工厂的bean id
        factory-method为实例工厂中的相应方法
    -->
    <!--<bean id="demoFactory" class="testInject.factory.MyBeanFactory"/>-->
    <!--<bean id="demoBeanFactory" factory-bean="demoFactory" factory-method="createDemoImpl"/>-->

    <!--
        作用域
        singleton 单例
        prototype 多例
    -->
    <!--<bean id="demoBeanScope" class="testScope.DemoImpl" scope="singleton"/>-->
    <!--<bean id="demoBeanScope" class="testScope.DemoImpl" scope="prototype"/>-->

    <!--
        Bean的生命周期
        初始化和销毁
        init-method为初始化函数
        destroy-method为销毁函数
    -->
    <!--<bean id="demoBeanInitDestroy" class="testLifeCycle.DemoImpl" init-method="myInit" destroy-method="myDestroy"/>-->

    <!--
        前后置处理器，动态代理
    -->
    <!--<bean id="demoBeanPostProcessor" class="testLifeCycle.testBeanPostProcessor.DemoImpl"/>-->
    <!--<bean class="testLifeCycle.testBeanPostProcessor.MyBeanPostProcessor"/>-->

    <!--
        构造函数配置
        <constructor-arg> 用于配置构造方法一个参数argument
			方案一：
                name ：参数的名称
			方案二：
                index ：参数的索引号，从0开始 。如果只有索引，匹配到了多个构造方法时，默认使用第一个。
                type ：确定参数类型
			填充值：
                value：设置普通数据
                ref：引用数据，一般是另一个bean id值
    -->
    <!--<bean id="studentConstructor" class="testXml.constructor.Student">-->
    <!--<constructor-arg name="id" value="1"/>-->
    <!--<constructor-arg name="name" value="Benjamin"/>-->
    <!--<constructor-arg name="age" value="19"/>-->
    <!--</bean>-->

    <!--
        set方法配置
        * 普通数据
			<property name="" value="值">
			等效
			<property name="">
				<value>值
		* 引用数据
			<property name="" ref="另一个bean">
			等效
			<property name="">
				<ref bean="另一个bean"/>

    -->
    <!--<bean id="personBeanSetter" class="testXml.setter.Person">-->
    <!--&lt;!&ndash; 两种设置基本数据类型值的方式 &ndash;&gt;-->
    <!--<property name="name" value="Benjamin"/>-->
    <!--<property name="age">-->
    <!--<value>19</value>-->
    <!--</property>-->

    <!--&lt;!&ndash; 设置引用类型 &ndash;&gt;-->
    <!--<property name="homeAddress" ref="homeAddress"/>-->
    <!--<property name="companyAddress">-->
    <!--<ref bean="companyAddress"/>-->
    <!--</property>-->
    <!--</bean>-->
    <!--<bean id="homeAddress" class="testXml.setter.Address">-->
    <!--<property name="addr" value="宝鸡"/>-->
    <!--<property name="tel" value="1234678"/>-->
    <!--</bean>-->
    <!--<bean id="companyAddress" class="testXml.setter.Address">-->
    <!--<property name="addr" value="上海"/>-->
    <!--<property name="tel" value="12312"/>-->
    <!--</bean>-->

    <!--
        集合的注入都是给<property>添加子标签
            数组：<array>
            List：<list>
            Set：<set>
            Map：<map>
            Properties：<props>

            其中的普通数据：<value>
                  引用数据：<ref>
    -->
    <!--<bean id="dataBeanCollection" class="testXml.collection.Data">-->
    <!--<property name="arrayData">-->
    <!--<array>-->
    <!--<value>a</value>-->
    <!--<value>b</value>-->
    <!--<value>c</value>-->
    <!--<value>d</value>-->
    <!--</array>-->
    <!--</property>-->
    <!--<property name="listDate">-->
    <!--<list>-->
    <!--<value>1</value>-->
    <!--<value>2</value>-->
    <!--<value>3</value>-->
    <!--<value>4</value>-->
    <!--</list>-->
    <!--</property>-->
    <!--<property name="setData">-->
    <!--<set>-->
    <!--<value>A</value>-->
    <!--<value>B</value>-->
    <!--<value>C</value>-->
    <!--</set>-->
    <!--</property>-->
    <!--<property name="mapData">-->
    <!--<map>-->
    <!--<entry key="a" value="A"/>-->
    <!--<entry>-->
    <!--<key>-->
    <!--<value>b</value>-->
    <!--</key>-->
    <!--<value>B</value>-->
    <!--</entry>-->
    <!--</map>-->
    <!--</property>-->
    <!--<property name="propertiesData">-->
    <!--<props>-->
    <!--<prop key="name">Benjamin</prop>-->
    <!--<prop key="age">19</prop>-->
    <!--</props>-->
    <!--</property>-->
    <!--</bean>-->

    <!--
        spring实现半自动化的代理生成
    -->
    <!--&lt;!&ndash;创建目标类 &ndash;&gt;-->
    <!--<bean id="service" class="testAOP.semiAuto.ServiceImpl"/>-->
    <!--&lt;!&ndash; 切面类 &ndash;&gt;-->
    <!--<bean id="myAspect" class="testAOP.semiAuto.MyAspect"/>-->
    <!--&lt;!&ndash; 代理类 &ndash;&gt;-->
    <!--<bean id="proxyService" class="org.springframework.aop.framework.ProxyFactoryBean">-->
    <!--&lt;!&ndash; 接口，若有多个接口，可使用子标签array &ndash;&gt;-->
    <!--<property name="interfaces" value="testAOP.semiAuto.Service"/>-->
    <!--&lt;!&ndash; 目标对象，使用bean id &ndash;&gt;-->
    <!--<property name="target" ref="service"/>-->
    <!--&lt;!&ndash; 切面类名称，因为是名称，所以是个字符串，用value &ndash;&gt;-->
    <!--<property name="interceptorNames" value="myAspect"/>-->
    <!--</bean>-->

    <!--
        spring实现aop
    -->
    <!--创建目标类 -->
    <bean id="service" class="testAOP.Auto.ServiceImpl"/>
    <!-- 切面类 -->
    <bean id="myAspect" class="testAOP.Auto.MyAspect"/>
    <!--
        aop编程
        1 导入命名空间
		2 使用 <aop:config>进行配置
				proxy-target-class="true" 声明时使用cglib代理
			<aop:pointcut> 切入点 ，从目标对象获得具体方法
			<aop:advisor> 特殊的切面，只有一个通知 和 一个切入点
				advice-ref 通知引用
				pointcut-ref 切入点引用
		3 切入点表达式
			execution(     *    testAOP.semiAuto. *.      *        (..))
			选择方法   返回值任意       包      类名任意 方法名任意 参数任意
     -->
    <aop:config >
        <aop:pointcut id="servicePointCut" expression="execution(* testAOP.Auto.*.*(..))"/>
        <aop:advisor advice-ref="myAspect" pointcut-ref="servicePointCut"/>
    </aop:config>

</beans>